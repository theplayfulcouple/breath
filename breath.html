<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Breath Rhythm Prototype</title>

  <style>
    html, body { width:100%; height:100%; margin:0; }

    .scene{
      position:relative;
      width:100%;
      height:100%;
      overflow:hidden;
      background:#2a0a0a;
    }

    .field{
      position:absolute;
      inset:-12%;
      background-image: url("https://static.wixstatic.com/media/2a3958_ff2e3bfa846c4d7ebb7d4a9be59bf06d~mv2.png");
      background-size: cover;
      background-position: 50% 50%;
      transform: translate3d(0,0,0) scale(1.05);
      will-change: transform, background-position, filter;
      filter: saturate(1.07) contrast(1.04) brightness(1.00);
      z-index: 1;
    }

    .circle{
      position:absolute;
      left:50%;
      border-radius:50%;
      transform: translate(-50%, -50%) scale(0.10);
      opacity: 0;
      pointer-events:none;
      will-change: transform, opacity;
    }

    .belly{
      top: 62%;
      width: 340px;
      height: 340px;
      background: rgba(255,255,255,0.22);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.10) inset;
      z-index: 3;
    }

    .lungs{
      top: 44%;
      width: 320px;
      height: 320px;
      background: rgba(255,255,255,0.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset;
      z-index: 4;
    }

    .vignette{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 5;
      background:
        radial-gradient(120% 100% at 50% 55%,
          rgba(0,0,0,0) 35%,
          rgba(0,0,0,0.26) 78%,
          rgba(0,0,0,0.55) 100%);
    }

    /* ---- toggles ---- */
    .toggle{
      position:absolute;
      left:18px;
      z-index: 6;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.28);
      color: rgba(255,255,255,0.88);
      font: 14px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(6px);
    }
    .toggleDot{
      width:10px;
      height:10px;
      border-radius: 50%;
      background: rgba(255,255,255,0.30);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.10);
      flex: 0 0 auto;
    }
    .toggle.isOn .toggleDot{
      background: rgba(255,255,255,0.85);
    }

    #voiceToggle{ bottom:66px; }
    #musicToggle{ bottom:18px; }
    #torchToggle { bottom:114px; }

    /* ---- session timer ---- */
    .sessionTimer{
      position:absolute;
      bottom:18px;
      right:18px;
      z-index: 6;
      padding:8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.28);
      color: rgba(255,255,255,0.85);
      font: 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: 0.04em;
      backdrop-filter: blur(6px);
      user-select:none;
    }

    /* -----------------------------
       Resonance bars (single source of truth)
       ----------------------------- */
    .resWrap{
      position:absolute;
      top:18px;
      left:50%;
      transform:translateX(-50%);
      z-index:7;
    }

    .resBars{
      display:flex;
      align-items:flex-end;
      gap:8px;
      padding:10px 14px;
      border-radius:999px;
      background:rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(6px);
    }

    .resBar{
      width:10px;
      border-radius:999px;
      background:rgba(255,255,255,0.90);
      opacity:0.12;
      transform: translateZ(0);
      transition: opacity 300ms ease, transform 300ms ease;
    }

    .resBar.on{ opacity:0.70; }

    .resBar.top{
      opacity:0.95;
      transform:scaleY(1.12);
    }

    /* ---- start sensor button (keeps your design) ---- */
    .sensorBtn{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      z-index:8;
      padding:14px 18px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.28);
      color:rgba(255,255,255,0.90);
      font: 16px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      backdrop-filter: blur(6px);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    /* hidden camera elements */
    #ppgVideo { display:none; }
    #ppgFrame { display:none; }
  </style>
</head>

<body>
  <div class="scene">
    <div class="field" id="field"></div>
    <div class="circle belly" id="belly"></div>
    <div class="circle lungs" id="lungs"></div>
    <div class="vignette"></div>

    <!-- Resonance bars -->
    <div class="resWrap">
      <div class="resBars" id="resBars"></div>
    </div>

    <div class="sessionTimer" id="sessionTimer">00:00</div>

    <button class="toggle" id="voiceToggle" type="button" aria-pressed="false">
      <span class="toggleDot" aria-hidden="true"></span>
      <span id="voiceLabel">voice off</span>
    </button>

    <button class="toggle" id="musicToggle" type="button" aria-pressed="false">
      <span class="toggleDot" aria-hidden="true"></span>
      <span id="musicLabel">music off</span>
    </button>

    <button class="toggle" id="torchToggle" type="button" aria-pressed="false">
  <span class="toggleDot" aria-hidden="true"></span>
  <span id="torchLabel">torch off</span>
</button>

    <!-- Start sensor -->
    <button class="sensorBtn" id="sensorBtn" type="button">start sensor</button>

    <!-- hidden camera elements -->
    <video id="ppgVideo" playsinline></video>
    <canvas id="ppgFrame" width="160" height="120"></canvas>
  </div>

  <script>
    // =========================================================
    // Breath animation (stable clock)
    // =========================================================
    const inhale = 5000;
    const exhale = 5000;
    const rest   = 1000;
    const cycle  = inhale + exhale + rest;

    const bgExpand = 5200;
    const bgRelease = 5800;

    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const smoothstep = (t) => t*t*(3 - 2*t);

    const field = document.getElementById("field");
    const belly = document.getElementById("belly");
    const lungs = document.getElementById("lungs");

    const lungsBegin = 1400;
    const minScale = 0.10;
    const bellyMaxScale = 0.88;
    const lungsMaxScale = 1.06;

    function setCircle(el, scale, opacity){
      el.style.transform = `translate(-50%, -50%) scale(${scale.toFixed(4)})`;
      el.style.opacity = opacity.toFixed(3);
    }

    function bgWave(t){
      if (t < bgExpand) return smoothstep(t / bgExpand);
      const tr = (t - bgExpand) / bgRelease;
      return smoothstep(1 - tr);
    }

    // Breath phase helper (used by resonance)
    function getBreathPhaseFromNow(nowPerf){
      const t = (nowPerf - start) % cycle;
      if (t < inhale) return "inhale";
      if (t < inhale + exhale) return "exhale";
      return "rest";
    }

    // =========================================================
    // Audio (your original toggles unchanged)
    // =========================================================
    const musicUrl = "https://static.wixstatic.com/mp3/2a3958_3763516366fd407aa161448698e81dcd.mp3";
    const voiceUrl = "https://static.wixstatic.com/mp3/2a3958_73c22d87f3a34cccbde19d6dc0c3eea7.mp3";

    const voiceBreathStartSec = 108.0;
    const voiceBreathStartMs  = voiceBreathStartSec * 1000;

    const music = new Audio(musicUrl);
    music.preload = "auto";
    music.loop = true;

    const voice = new Audio(voiceUrl);
    voice.preload = "auto";
    voice.loop = false;

    let musicOn = false;
    let voiceOn = false;

    const start = performance.now();

    const voiceBtn = document.getElementById("voiceToggle");
    const voiceLabel = document.getElementById("voiceLabel");
    const musicBtn = document.getElementById("musicToggle");
    const musicLabel = document.getElementById("musicLabel");

    function setToggle(btn, labelEl, isOn, onText, offText){
      btn.classList.toggle("isOn", isOn);
      btn.setAttribute("aria-pressed", String(isOn));
      labelEl.textContent = isOn ? onText : offText;
    }

    setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
    setToggle(musicBtn, musicLabel, false, "music on", "music off");

    let voiceStartTimeout = null;

    function scheduleVoiceStart(){
      if (voiceStartTimeout) clearTimeout(voiceStartTimeout);

      const now = performance.now();
      const currentPhase = (now - start) % cycle;

      const desiredPhase = (cycle - (voiceBreathStartMs % cycle)) % cycle;
      const delayMs = (desiredPhase - currentPhase + cycle) % cycle;

      voiceStartTimeout = setTimeout(async () => {
        voiceStartTimeout = null;
        if (!voiceOn) return;

        try{
          voice.currentTime = 0;
          await voice.play();
        }catch(e){
          voiceOn = false;
          setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
        }
      }, delayMs);
    }

    // =========================================================
    // Resonance bars (unchanged)
    // =========================================================
    const BAR_COUNT = 10;
    const resBarsEl = document.getElementById("resBars");
    const bars = [];

    if (resBarsEl){
      for (let i = 0; i < BAR_COUNT; i++){
        const b = document.createElement("div");
        b.className = "resBar";
        b.style.height = (8 + i * 3) + "px";
        resBarsEl.appendChild(b);
        bars.push(b);
      }
    }

    const clearResonance = () => {
      bars.forEach((bar) => {
        bar.classList.remove("on");
        bar.classList.remove("top");
      });
    };

    const setResonanceLevel = (level) => {
      const lv = Math.max(1, Math.min(10, Math.round(level)));
      bars.forEach((bar, i) => {
        bar.classList.toggle("on", i < lv);
        bar.classList.toggle("top", i === lv - 1);
      });
    };

    // =========================================================
    // PPG (camera) -> RESONANCE (1â€“10) based on breath phase
    // =========================================================
    const sensorBtn = document.getElementById("sensorBtn");

    const torchBtn = document.getElementById("torchToggle");
const torchLabel = document.getElementById("torchLabel");
let torchOn = false;
    
    const video = document.getElementById("ppgVideo");
    const frameCanvas = document.getElementById("ppgFrame");
    const frameCtx = frameCanvas.getContext("2d", { willReadFrequently: true });

    let ppgStream = null;
    let ppgRaf = null;

    const fsTarget = 30;
    const bufLen = 10 * fsTarget;
    const sig = new Float32Array(bufLen);
    let idx = 0;

    const peakTimes = [];

    // Breath-phase beat buckets (per cycle)
let inhaleIBIs = [];
let exhaleIBIs = [];
let prevPeakT = 0;

// Track which breath cycle we're in
let lastCycleIndex = -1;

function breathPhase(nowMs){
  const t = (nowMs - start) % cycle; // uses your existing breath clock
  if (t < inhale) return "inhale";
  if (t < inhale + exhale) return "exhale";
  return "rest";
}
    
    let lastPeakT = 0;
    let lastAbove = false;

    // --- NEW: beat list used for resonance ---
    // Each entry: { t: perfNowMs, ibi: ms, phase: "inhale"|"exhale"|"rest" }
   
   

    function meanStd(arr) {
      let m = 0;
      for (let i = 0; i < arr.length; i++) m += arr[i];
      m /= arr.length;
      let v = 0;
      for (let i = 0; i < arr.length; i++) {
        const d = arr[i] - m;
        v += d * d;
      }
      v /= arr.length;
      return { mean: m, std: Math.sqrt(v) };
    }

    function computeFrameAverages(frameData) {
      let r = 0, g = 0, b = 0;
      const n = frameData.length / 4;
      for (let i = 0; i < frameData.length; i += 4) {
        r += frameData[i];
        g += frameData[i + 1];
        b += frameData[i + 2];
      }
      r /= n; g /= n; b /= n;

      const brightness = (r + g + b) / 3;
      const redness = r / (g + b + 1e-6);
      return { brightness, redness, g };
    }

    function pushSample(v) {
      sig[idx] = v;
      idx = (idx + 1) % bufLen;
    }

   // --- Resonance data (beat list with breath phase) ---
const beats = [];
let lastBeatT = 0;

function breathPhaseFromNow(nowMs){
  const t = (nowMs - start) % cycle; // uses your existing breath clock
  if (t < inhale) return "inhale";
  if (t < inhale + exhale) return "exhale";
  return "rest";
}

function recordBeat(nowPerf){
  if (!lastBeatT){
    lastBeatT = nowPerf;
    return;
  }

  const ibi = nowPerf - lastBeatT;
  lastBeatT = nowPerf;

  // sanity window
  if (ibi < 300 || ibi > 2000) return;

  beats.push({
    t: nowPerf,
    ibi,
    phase: breathPhaseFromNow(nowPerf)
  });

  // keep last 25 seconds
  const keepMs = 25000;
  while (beats.length && (nowPerf - beats[0].t) > keepMs) beats.shift();
}

    // Simple correlation helper (phase -> IBI)
    function corrPhaseIbi(items){
      // inhale expects shorter IBI, exhale expects longer IBI
      // encode: inhale = -1, exhale = +1, rest = 0
      const xs = [];
      const ys = [];
      for (const it of items){
        if (it.phase === "rest") continue;
        const x = (it.phase === "inhale") ? -1 : +1;
        xs.push(x);
        ys.push(it.ibi);
      }
      if (xs.length < 6) return 0;

      let mx = 0, my = 0;
      for (let i=0;i<xs.length;i++){ mx += xs[i]; my += ys[i]; }
      mx /= xs.length; my /= ys.length;

      let num = 0, dx = 0, dy = 0;
      for (let i=0;i<xs.length;i++){
        const a = xs[i]-mx;
        const b = ys[i]-my;
        num += a*b;
        dx += a*a;
        dy += b*b;
      }
      const den = Math.sqrt(dx*dy) + 1e-9;
      return num/den; // -1..+1
    }

    function computeResonanceLevel(nowPerf){
      // need enough beats to be meaningful
      if (beats.length < 8) return 1;

      // means for inhale vs exhale
      const inh = [];
      const exh = [];
      for (const b of beats){
        if (b.phase === "inhale") inh.push(b.ibi);
        else if (b.phase === "exhale") exh.push(b.ibi);
      }
      if (inh.length < 3 || exh.length < 3) return 2;

      const mInh = inh.reduce((a,v)=>a+v,0)/inh.length;
      const mExh = exh.reduce((a,v)=>a+v,0)/exh.length;

      // amplitude: exhale should be longer than inhale
      const meanAll = (mInh + mExh) / 2;
      const amp = (mExh - mInh) / (meanAll + 1e-9); // roughly 0..0.2+
      const ampScore = clamp01((amp - 0.01) / 0.12); // ignore tiny differences

      // synchrony: phase-locked relationship
      const c = corrPhaseIbi(beats);       // want positive
      const syncScore = clamp01((Math.max(0, c) - 0.05) / 0.55);

      // stability: how noisy the IBIs are overall
      const allIbi = beats.map(b=>b.ibi);
      const { mean, std } = meanStd(allIbi);
      const cv = std / (mean + 1e-9); // coefficient of variation
      const stableScore = clamp01(1 - (cv - 0.03) / 0.12);

      // combine (most weight on synchrony)
      const score = clamp01(syncScore * 0.60 + ampScore * 0.25 + stableScore * 0.15);

      // map to 1..10
      return 1 + Math.round(score * 9);
    }

    function detectPeaks() {
      const ordered = new Float32Array(bufLen);
      for (let i = 0; i < bufLen; i++) ordered[i] = sig[(idx + i) % bufLen];

      const N = Math.min(bufLen, Math.floor(3 * fsTarget));
      const tail = ordered.subarray(bufLen - N);
      const { mean, std } = meanStd(tail);

      const thr = mean + 0.6 * std;
      const cur = ordered[bufLen - 1];
      const now = performance.now();

      const refractoryMs = 300;
      const above = cur > thr;

      if (!lastAbove && above && (now - lastPeakT) > refractoryMs) {
        peakTimes.push(now);
        lastPeakT = now;
        recordBeat(now);

        // keep (still fine to keep, but resonance now uses beats[])
        const keepMs = 20000;
        while (peakTimes.length && (now - peakTimes[0]) > keepMs) peakTimes.shift();

        // NEW: record beat for resonance
      

        // NEW: update bars from resonance model
        const level = computeResonanceLevel(now);
        setResonanceLevel(level);
      }
      lastAbove = above;
    }

    function ppgLoop(){
      const w = frameCanvas.width, h = frameCanvas.height;

      frameCtx.drawImage(video, 0, 0, w, h);
      const img = frameCtx.getImageData(0, 0, w, h);
      const { brightness, redness, g } = computeFrameAverages(img.data);

      pushSample(g);

      // finger gate (prevents ghost readings)
      const fingerLikely = (brightness < 140) && (redness > 1.05);
      if (!fingerLikely) {
        clearResonance();
        peakTimes.length = 0;
        beats.length = 0;
        lastBeatT = 0;
        lastAbove = false;
        lastPeakT = 0;
        ppgRaf = requestAnimationFrame(ppgLoop);
        return;
      }

      detectPeaks();

      // gentle drift update even if no new beat this frame
      // (keeps the ladder responsive but not twitchy)
      if (beats.length >= 8) {
        const now = performance.now();
        const level = computeResonanceLevel(now);
        setResonanceLevel(level);
      }

      ppgRaf = requestAnimationFrame(ppgLoop);
    }

    async function startSensor(){
      if (ppgStream) return;

      try{
        ppgStream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });

        video.srcObject = ppgStream;
        await video.play();
        torchBtn.disabled = false;

        // hide button once running
        if (sensorBtn) sensorBtn.style.display = "none";

        // reset buffers
        idx = 0;
        sig.fill(0);
        peakTimes.length = 0;
        beats.length = 0;
        lastBeatT = 0;
        lastAbove = false;
        lastPeakT = 0;

        ppgLoop();
      }catch(e){
        clearResonance();
        alert("camera permission failed. open this page in safari and allow camera.");
      }
    }

    sensorBtn.addEventListener("click", startSensor);

    // =========================================================
    // Animation loop (your original)
    // =========================================================
    function frame(now){
      const t = (now - start) % cycle;

      if (t < inhale){
        const bellyE = smoothstep(t / inhale);
        const plRaw = (t - lungsBegin) / (inhale - lungsBegin);
        const lungsE = smoothstep(clamp01(plRaw));

        const bellyScale = minScale + (bellyMaxScale - minScale) * bellyE;
        const lungsScale = minScale + (lungsMaxScale - minScale) * lungsE;

        setCircle(belly, bellyScale, 0.15 + 0.70 * bellyE);
        setCircle(lungs, lungsScale, 0.12 + 0.62 * lungsE);
      }
      else if (t < inhale + exhale){
        const te = (t - inhale) / exhale;
        const e = smoothstep(1 - te);

        const scaleB = minScale + (bellyMaxScale - minScale) * e;
        const scaleL = minScale + (lungsMaxScale - minScale) * e;

        setCircle(belly, scaleB, 0.15 + 0.70 * e);
        setCircle(lungs, scaleL, 0.12 + 0.62 * e);
      }
      else {
        setCircle(belly, minScale, 0);
        setCircle(lungs, minScale, 0);
      }

      const bg = bgWave(t);
      const zoom = 1.05 + 0.070 * bg;
      const driftX = 50 + 3.2 * bg;
      const driftY = 50 - 3.4 * bg;

      field.style.transform = `translate3d(0,0,0) scale(${zoom.toFixed(4)})`;
      field.style.backgroundPosition = `${driftX.toFixed(3)}% ${driftY.toFixed(3)}%`;
      field.style.filter = `saturate(1.07) contrast(1.04) brightness(${(1.00 + 0.085 * bg).toFixed(3)})`;

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Voice toggle (unchanged)
    voiceBtn.addEventListener("click", async () => {
      if (!voiceOn){
        voiceOn = true;
        setToggle(voiceBtn, voiceLabel, true, "voice on", "voice off");
        scheduleVoiceStart();
      }else{
        voiceOn = false;
        if (voiceStartTimeout) clearTimeout(voiceStartTimeout);
        voiceStartTimeout = null;
        voice.pause();
        setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
      }
    });

    // Music toggle (unchanged)
    musicBtn.addEventListener("click", async () => {
      if (!musicOn){
        musicOn = true;
        setToggle(musicBtn, musicLabel, true, "music on", "music off");
        try{
          await music.play();
        }catch(e){
          musicOn = false;
          setToggle(musicBtn, musicLabel, false, "music on", "music off");
        }
      }else{
        musicOn = false;
        music.pause();
        setToggle(musicBtn, musicLabel, false, "music on", "music off");
      }
    });

    torchBtn.addEventListener("click", async () => {
  if (!ppgStream) return;

  torchOn = !torchOn;

  const track = ppgStream.getVideoTracks()[0];
  const capabilities = track.getCapabilities();

  if (!capabilities.torch) {
    alert("Torch not supported on this device.");
    return;
  }

  await track.applyConstraints({
    advanced: [{ torch: torchOn }]
  });

  torchBtn.classList.toggle("isOn", torchOn);
  torchLabel.textContent = torchOn ? "torch on" : "torch off";
});

    // Session timer (unchanged)
    const timerEl = document.getElementById("sessionTimer");
    let elapsedMs = 0;
    let lastTick = performance.now();

    function updateTimer(now){
      if (!document.hidden){
        elapsedMs += now - lastTick;
      }
      lastTick = now;

      const totalSeconds = Math.floor(elapsedMs / 1000);
      const mins = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
      const secs = String(totalSeconds % 60).padStart(2, "0");
      timerEl.textContent = `${mins}:${secs}`;

      requestAnimationFrame(updateTimer);
    }
    requestAnimationFrame(updateTimer);

    // If the tab is hidden, stop the camera to avoid weird iOS behaviour
    document.addEventListener("visibilitychange", () => {
      if (document.hidden){
        if (ppgRaf) cancelAnimationFrame(ppgRaf);
        ppgRaf = null;
        if (ppgStream){
          ppgStream.getTracks().forEach(t => t.stop());
          ppgStream = null;
        }
        clearResonance();
        // show the button again when they come back
        if (sensorBtn) sensorBtn.style.display = "";
      }

      if (document.hidden){
        if (voiceOn){
          voiceOn = false;
          if (voiceStartTimeout) clearTimeout(voiceStartTimeout);
          voiceStartTimeout = null;
          voice.pause();
          setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
        }
        if (musicOn){
          musicOn = false;
          music.pause();
          setToggle(musicBtn, musicLabel, false, "music on", "music off");
        }
      }
    });
  </script>
</body>
</html>
