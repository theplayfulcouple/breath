<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Breath Rhythm Prototype</title>

  <style>
    html, body { width:100%; height:100%; margin:0; }

    .scene{
      position:relative;
      width:100%;
      height:100%;
      overflow:hidden;
      background:#2a0a0a;
    }

    .field{
      position:absolute;
      inset:-12%;
      background-image: url("https://static.wixstatic.com/media/2a3958_ff2e3bfa846c4d7ebb7d4a9be59bf06d~mv2.png");
      background-size: cover;
      background-position: 50% 50%;
      transform: translate3d(0,0,0) scale(1.05);
      will-change: transform, background-position, filter;
      filter: saturate(1.07) contrast(1.04) brightness(1.00);
      z-index: 1;
    }

    .circle{
      position:absolute;
      left:50%;
      border-radius:50%;
      transform: translate(-50%, -50%) scale(0.10);
      opacity: 0;
      pointer-events:none;
      will-change: transform, opacity;
    }

    .belly{
      top: 62%;
      width: 340px;
      height: 340px;
      background: rgba(255,255,255,0.22);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.10) inset;
      z-index: 3;
    }

    .lungs{
      top: 44%;
      width: 320px;
      height: 320px;
      background: rgba(255,255,255,0.18);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset;
      z-index: 4;
    }

    .vignette{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 5;
      background:
        radial-gradient(120% 100% at 50% 55%,
          rgba(0,0,0,0) 35%,
          rgba(0,0,0,0.26) 78%,
          rgba(0,0,0,0.55) 100%);
    }

    /* ---- toggles ---- */
    .toggle{
      position:absolute;
      left:18px;
      z-index: 6;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.28);
      color: rgba(255,255,255,0.88);
      font: 14px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(6px);
    }
    .toggleDot{
      width:10px;
      height:10px;
      border-radius: 50%;
      background: rgba(255,255,255,0.30);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.10);
      flex: 0 0 auto;
    }
    .toggle.isOn .toggleDot{
      background: rgba(255,255,255,0.85);
    }

    #voiceToggle{ bottom:66px; }
    #musicToggle{ bottom:18px; }

    /* ---- session timer ---- */
    .sessionTimer{
      position:absolute;
      bottom:18px;
      right:18px;
      z-index: 6;
      padding:8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.28);
      color: rgba(255,255,255,0.85);
      font: 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: 0.04em;
      backdrop-filter: blur(6px);
      user-select:none;
    }

    /* -----------------------------
       Resonance bars (single source of truth)
       ----------------------------- */
    .resWrap{
      position:absolute;
      top:18px;
      left:50%;
      transform:translateX(-50%);
      z-index:7;
    }

    .resBars{
      display:flex;
      align-items:flex-end;
      gap:8px;
      padding:10px 14px;
      border-radius:999px;
      background:rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(6px);
    }

    .resBar{
      width:10px;
      border-radius:999px;
      background:rgba(255,255,255,0.90);
      opacity:0.12;
      transform: translateZ(0);
      transition: opacity 300ms ease, transform 300ms ease;
    }

    .resBar.on{ opacity:0.70; }

    .resBar.top{
      opacity:0.95;
      transform:scaleY(1.12);
    }

    /* ---- start sensor button (keeps your design) ---- */
    .sensorBtn{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      z-index:8;
      padding:14px 18px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.28);
      color:rgba(255,255,255,0.90);
      font: 16px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      backdrop-filter: blur(6px);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    /* hidden camera elements */
    #ppgVideo { display:none; }
    #ppgFrame { display:none; }
  </style>
</head>

<body>
  <div class="scene">
    <div class="field" id="field"></div>
    <div class="circle belly" id="belly"></div>
    <div class="circle lungs" id="lungs"></div>
    <div class="vignette"></div>

    <!-- Resonance bars -->
    <div class="resWrap">
      <div class="resBars" id="resBars"></div>
    </div>

    <div class="sessionTimer" id="sessionTimer">00:00</div>

    <button class="toggle" id="voiceToggle" type="button" aria-pressed="false">
      <span class="toggleDot" aria-hidden="true"></span>
      <span id="voiceLabel">voice off</span>
    </button>

    <button class="toggle" id="musicToggle" type="button" aria-pressed="false">
      <span class="toggleDot" aria-hidden="true"></span>
      <span id="musicLabel">music off</span>
    </button>

    <!-- Start sensor -->
    <button class="sensorBtn" id="sensorBtn" type="button">start sensor</button>

    <!-- hidden camera elements -->
    <video id="ppgVideo" playsinline></video>
    <canvas id="ppgFrame" width="160" height="120"></canvas>
  </div>

  <script>
    // =========================================================
    // Breath animation (stable clock)
    // =========================================================
    const inhale = 5000;
    const exhale = 5000;
    const rest   = 1000;
    const cycle  = inhale + exhale + rest;

    const bgExpand = 5200;
    const bgRelease = 5800;

    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const smoothstep = (t) => t*t*(3 - 2*t);

    const field = document.getElementById("field");
    const belly = document.getElementById("belly");
    const lungs = document.getElementById("lungs");

    const lungsBegin = 1400;
    const minScale = 0.10;
    const bellyMaxScale = 0.88;
    const lungsMaxScale = 1.06;

    function setCircle(el, scale, opacity){
      el.style.transform = `translate(-50%, -50%) scale(${scale.toFixed(4)})`;
      el.style.opacity = opacity.toFixed(3);
    }

    function bgWave(t){
      if (t < bgExpand) return smoothstep(t / bgExpand);
      const tr = (t - bgExpand) / bgRelease;
      return smoothstep(1 - tr);
    }

    // =========================================================
    // Audio (your original toggles unchanged)
    // =========================================================
    const musicUrl = "https://static.wixstatic.com/mp3/2a3958_3763516366fd407aa161448698e81dcd.mp3";
    const voiceUrl = "https://static.wixstatic.com/mp3/2a3958_73c22d87f3a34cccbde19d6dc0c3eea7.mp3";

    const voiceBreathStartSec = 108.0;
    const voiceBreathStartMs  = voiceBreathStartSec * 1000;

    const music = new Audio(musicUrl);
    music.preload = "auto";
    music.loop = true;

    const voice = new Audio(voiceUrl);
    voice.preload = "auto";
    voice.loop = false;

    let musicOn = false;
    let voiceOn = false;

    const start = performance.now();

    const voiceBtn = document.getElementById("voiceToggle");
    const voiceLabel = document.getElementById("voiceLabel");
    const musicBtn = document.getElementById("musicToggle");
    const musicLabel = document.getElementById("musicLabel");

    function setToggle(btn, labelEl, isOn, onText, offText){
      btn.classList.toggle("isOn", isOn);
      btn.setAttribute("aria-pressed", String(isOn));
      labelEl.textContent = isOn ? onText : offText;
    }

    setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
    setToggle(musicBtn, musicLabel, false, "music on", "music off");

    let voiceStartTimeout = null;

    function scheduleVoiceStart(){
      if (voiceStartTimeout) clearTimeout(voiceStartTimeout);

      const now = performance.now();
      const currentPhase = (now - start) % cycle;

      const desiredPhase = (cycle - (voiceBreathStartMs % cycle)) % cycle;
      const delayMs = (desiredPhase - currentPhase + cycle) % cycle;

      voiceStartTimeout = setTimeout(async () => {
        voiceStartTimeout = null;
        if (!voiceOn) return;

        try{
          voice.currentTime = 0;
          await voice.play();
        }catch(e){
          voiceOn = false;
          setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
        }
      }, delayMs);
    }

    // =========================================================
    // Resonance bars (unchanged)
    // =========================================================
    const BAR_COUNT = 10;
    const resBarsEl = document.getElementById("resBars");
    const bars = [];

    if (resBarsEl){
      for (let i = 0; i < BAR_COUNT; i++){
        const b = document.createElement("div");
        b.className = "resBar";
        b.style.height = (8 + i * 3) + "px";
        resBarsEl.appendChild(b);
        bars.push(b);
      }
    }

    const clearResonance = () => {
      bars.forEach((bar) => {
        bar.classList.remove("on");
        bar.classList.remove("top");
      });
    };

    const setResonanceLevel = (level) => {
      bars.forEach((bar, i) => {
        bar.classList.toggle("on", i < level);
        bar.classList.toggle("top", i === level - 1);
      });
    };

    // =========================================================
    // PPG (camera) -> drives bars directly (no other page)
    // =========================================================
    const sensorBtn = document.getElementById("sensorBtn");
    const video = document.getElementById("ppgVideo");
    const frameCanvas = document.getElementById("ppgFrame");
    const frameCtx = frameCanvas.getContext("2d", { willReadFrequently: true });

    let ppgStream = null;
    let ppgRaf = null;

    const fsTarget = 30;
    const bufLen = 10 * fsTarget;
    const sig = new Float32Array(bufLen);
    let idx = 0;

    const peakTimes = [];
    let lastPeakT = 0;
    let lastAbove = false;

    function meanStd(arr) {
      let m = 0;
      for (let i = 0; i < arr.length; i++) m += arr[i];
      m /= arr.length;
      let v = 0;
      for (let i = 0; i < arr.length; i++) {
        const d = arr[i] - m;
        v += d * d;
      }
      v /= arr.length;
      return { mean: m, std: Math.sqrt(v) };
    }

    function computeFrameAverages(frameData) {
      let r = 0, g = 0, b = 0;
      const n = frameData.length / 4;
      for (let i = 0; i < frameData.length; i += 4) {
        r += frameData[i];
        g += frameData[i + 1];
        b += frameData[i + 2];
      }
      r /= n; g /= n; b /= n;

      const brightness = (r + g + b) / 3;
      const redness = r / (g + b + 1e-6);
      return { brightness, redness, g };
    }

    function pushSample(v) {
      sig[idx] = v;
      idx = (idx + 1) % bufLen;
    }

    function detectPeaks() {
      const ordered = new Float32Array(bufLen);
      for (let i = 0; i < bufLen; i++) ordered[i] = sig[(idx + i) % bufLen];

      const N = Math.min(bufLen, Math.floor(3 * fsTarget));
      const tail = ordered.subarray(bufLen - N);
      const { mean, std } = meanStd(tail);

      const thr = mean + 0.6 * std;
      const cur = ordered[bufLen - 1];
      const now = performance.now();

      const refractoryMs = 300;
      const above = cur > thr;

      if (!lastAbove && above && (now - lastPeakT) > refractoryMs) {
        peakTimes.push(now);
        lastPeakT = now;

        const keepMs = 20000;
        while (peakTimes.length && (now - peakTimes[0]) > keepMs) peakTimes.shift();
      }
      lastAbove = above;
    }

    function bpmToBars(bpm){
      // same mapping you had: 55..110 -> 1..10 (clamped)
      const level = Math.max(1, Math.min(10, Math.round(((bpm - 55) / 55) * 9 + 1)));
      setResonanceLevel(level);
    }

    function estimateHRAndUpdateBars() {
      const now = performance.now();
      const windowMs = 8000;
      const recent = peakTimes.filter(t => (now - t) <= windowMs);

      if (recent.length < 2) return;

      const ibis = [];
      for (let i = 1; i < recent.length; i++) ibis.push(recent[i] - recent[i - 1]);

      const filtered = ibis.filter(ms => ms >= 300 && ms <= 2000);
      if (filtered.length < 2) return;

      filtered.sort((a,b) => a-b);
      const mid = Math.floor(filtered.length / 2);
      const median = filtered.length % 2 ? filtered[mid] : (filtered[mid - 1] + filtered[mid]) / 2;

      const bpm = 60000 / median;
      const bpmRounded = Math.round(bpm);

      if (Number.isFinite(bpmRounded) && bpmRounded > 0) {
        bpmToBars(bpmRounded);
      }
    }

    function ppgLoop(){
      const w = frameCanvas.width, h = frameCanvas.height;

      frameCtx.drawImage(video, 0, 0, w, h);
      const img = frameCtx.getImageData(0, 0, w, h);
      const { brightness, redness, g } = computeFrameAverages(img.data);

      pushSample(g);

      // finger gate (prevents ghost readings)
      const fingerLikely = (brightness < 140) && (redness > 1.05);
      if (!fingerLikely) {
        clearResonance();
        peakTimes.length = 0;
        lastAbove = false;
        lastPeakT = 0;
        ppgRaf = requestAnimationFrame(ppgLoop);
        return;
      }

      detectPeaks();
      estimateHRAndUpdateBars();

      ppgRaf = requestAnimationFrame(ppgLoop);
    }

    async function startSensor(){
      if (ppgStream) return;

      try{
        ppgStream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });

        video.srcObject = ppgStream;
        await video.play();

        // hide button once running
        if (sensorBtn) sensorBtn.style.display = "none";

        // reset buffers
        idx = 0;
        sig.fill(0);
        peakTimes.length = 0;
        lastAbove = false;
        lastPeakT = 0;

        ppgLoop();
      }catch(e){
        clearResonance();
        alert("camera permission failed. open this page in safari and allow camera.");
      }
    }

    sensorBtn.addEventListener("click", startSensor);

    // =========================================================
    // Animation loop (your original)
    // =========================================================
    function frame(now){
      const t = (now - start) % cycle;

      if (t < inhale){
        const bellyE = smoothstep(t / inhale);
        const plRaw = (t - lungsBegin) / (inhale - lungsBegin);
        const lungsE = smoothstep(clamp01(plRaw));

        const bellyScale = minScale + (bellyMaxScale - minScale) * bellyE;
        const lungsScale = minScale + (lungsMaxScale - minScale) * lungsE;

        setCircle(belly, bellyScale, 0.15 + 0.70 * bellyE);
        setCircle(lungs, lungsScale, 0.12 + 0.62 * lungsE);
      }
      else if (t < inhale + exhale){
        const te = (t - inhale) / exhale;
        const e = smoothstep(1 - te);

        const scaleB = minScale + (bellyMaxScale - minScale) * e;
        const scaleL = minScale + (lungsMaxScale - minScale) * e;

        setCircle(belly, scaleB, 0.15 + 0.70 * e);
        setCircle(lungs, scaleL, 0.12 + 0.62 * e);
      }
      else {
        setCircle(belly, minScale, 0);
        setCircle(lungs, minScale, 0);
      }

      const bg = bgWave(t);
      const zoom = 1.05 + 0.070 * bg;
      const driftX = 50 + 3.2 * bg;
      const driftY = 50 - 3.4 * bg;

      field.style.transform = `translate3d(0,0,0) scale(${zoom.toFixed(4)})`;
      field.style.backgroundPosition = `${driftX.toFixed(3)}% ${driftY.toFixed(3)}%`;
      field.style.filter = `saturate(1.07) contrast(1.04) brightness(${(1.00 + 0.085 * bg).toFixed(3)})`;

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Voice toggle (unchanged)
    voiceBtn.addEventListener("click", async () => {
      if (!voiceOn){
        voiceOn = true;
        setToggle(voiceBtn, voiceLabel, true, "voice on", "voice off");
        scheduleVoiceStart();
      }else{
        voiceOn = false;
        if (voiceStartTimeout) clearTimeout(voiceStartTimeout);
        voiceStartTimeout = null;
        voice.pause();
        setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
      }
    });

    // Music toggle (unchanged)
    musicBtn.addEventListener("click", async () => {
      if (!musicOn){
        musicOn = true;
        setToggle(musicBtn, musicLabel, true, "music on", "music off");
        try{
          await music.play();
        }catch(e){
          musicOn = false;
          setToggle(musicBtn, musicLabel, false, "music on", "music off");
        }
      }else{
        musicOn = false;
        music.pause();
        setToggle(musicBtn, musicLabel, false, "music on", "music off");
      }
    });

    // Session timer (unchanged)
    const timerEl = document.getElementById("sessionTimer");
    let elapsedMs = 0;
    let lastTick = performance.now();

    function updateTimer(now){
      if (!document.hidden){
        elapsedMs += now - lastTick;
      }
      lastTick = now;

      const totalSeconds = Math.floor(elapsedMs / 1000);
      const mins = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
      const secs = String(totalSeconds % 60).padStart(2, "0");
      timerEl.textContent = `${mins}:${secs}`;

      requestAnimationFrame(updateTimer);
    }
    requestAnimationFrame(updateTimer);

    // If the tab is hidden, stop the camera to avoid weird iOS behaviour
    document.addEventListener("visibilitychange", () => {
      if (document.hidden){
        if (ppgRaf) cancelAnimationFrame(ppgRaf);
        ppgRaf = null;
        if (ppgStream){
          ppgStream.getTracks().forEach(t => t.stop());
          ppgStream = null;
        }
        clearResonance();
        // show the button again when they come back
        if (sensorBtn) sensorBtn.style.display = "";
      }

      if (document.hidden){
        if (voiceOn){
          voiceOn = false;
          if (voiceStartTimeout) clearTimeout(voiceStartTimeout);
          voiceStartTimeout = null;
          voice.pause();
          setToggle(voiceBtn, voiceLabel, false, "voice on", "voice off");
        }
        if (musicOn){
          musicOn = false;
          music.pause();
          setToggle(musicBtn, musicLabel, false, "music on", "music off");
        }
      }
    });
  </script>
</body>
</html>
